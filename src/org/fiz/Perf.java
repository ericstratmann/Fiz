package org.fiz;

import java.util.*;

/**
 * The Perf class contains various facilities for measuring the performance
 * of Fiz and applications built with it.  Note: these facilities do not
 * include synchronization, so they are not safe to access concurrently.
 */
public class Perf {
    // The following two fields are used by resetIntervals and recordInterval
    // to keep track of intervals.  IntervalNames records a name for each
    // interval, and intervalTimes records the ending time of the interval.
    static ArrayList<String> intervalNames = new ArrayList<String>();
    static ArrayList<Long> intervalTimes = new ArrayList<Long>();

    /**
     * Generates a human-readable string describing all of the intervals
     * that have been marked so far.
     * @param indent               Prepended to each line of output;
     *                             typically consists of spaces, which
     *                             result in the information being indented.
     * @return                     A string containing information
     *                             about the intervals.  If there have been no
     *                             calls to {@code markInterval} since the
     *                             last call to {@code resetIntervals} then
     *                             an empty string is returned.
     */
    public static String intervalInfo(String indent) {
        int length = intervalTimes.size();
        if (length <= 1) {
            return "";
        }
        double interval;
        double total = 0.0;
        StringBuilder result = new StringBuilder();
        for (int i = 1; i < intervalTimes.size(); i++) {
            interval = intervalTimes.get(i);
            interval -= intervalTimes.get(i-1);
            total += interval;
            result.append(String.format("%s%-20s %10.2fus\n", indent,
                    intervalNames.get(i), interval/1000.0));
        }
        interval = intervalTimes.get(intervalTimes.size()-1);
        interval -= intervalTimes.get(0);
        result.append(String.format("%s%-20s %10.2fus", indent,
                "Total", interval/1000.0));
        return result.toString();

    }

    /**
     * Record information indicating that the next interval has ended.
     * This method works in conjunction with {@code resetIntervals} and
     * {@code intervalInfo} analyze distribution of execution time over a
     * series of sequential operations.  Typically the methods are invoked
     * as follows:
     * <pre>
     *     resetIntervals();
     *     ...
     *     markInterval("a");
     *     ...
     *     markInterval("b");
     *     ...
     *     logger.info("Intervals:\n", intervalInfo("  "));
     * </pre>
     * Each time one of these methods is invoked, the current clock time
     * is recorded at a fine grain.  {@code intervalInfo} uses these
     * clock readings to print out the elapsed time from each call to
     * the next.  Notes that the calls to {@code markInterval} can
     * (and often are) distributed among several different code modules.
     * @param id                   Identifies the interval that just ended;
     *                             included in the message generated by
     *                            {@code intervalInfo}.
     */
    public static void markInterval(String id) {
        intervalNames.add(id);
        intervalTimes.add(System.nanoTime());
    }

    /**
     * Clearing existing interval information, and begin timing the first
     * in a new set of intervals.  This method is used in conjunction with
     * {@code markInterval} and {@code intervalInfo}; see
     * {@code markInterval} for details.
     */
    public static void resetIntervals() {
        intervalNames.clear();
        intervalNames.add ("start");
        intervalTimes.clear();
        intervalTimes.add(System.nanoTime());
    }
}
